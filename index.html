<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>D&D 5e explorer</title>
  <style>
    body {
      font-family: sans-serif;
      padding: 1em;
    }
    progress {
      width: 100%;
      height: 20px;
    }
    pre {
      max-height: 60vh;
      overflow-y: auto;
      background: #f5f5f5;
      padding: 1em;
      border: 1px solid #ccc;
    }
    button {
      margin-top: 1em;
    }
    .error {
      color: red;
      white-space: pre-wrap;
    }
  </style>
</head>
<body>
  <h1>D&D 5e explorer</h1>
  <p id="status">Initialisiere...</p>
  <progress id="progress" value="0" max="100"></progress>
  <pre id="output">Warte auf Start...</pre>
  <div id="error" class="error"></div>
  <button onclick="refreshData()">Daten neu laden</button>

  <script>
  const baseUrl = "https://www.dnd5eapi.co";
  const dbName = "dnd5e-db";
  const statusEl = document.getElementById("status");
  const progressEl = document.getElementById("progress");
  const outputEl = document.getElementById("output");
  const errorEl = document.getElementById("error");

  async function fetchJSON(url) {
    const res = await fetch(url);
    if (!res.ok) throw new Error(`${url} returned ${res.status}`);
    return res.json();
  }

  async function fetchEndpoints() {
    const api = await fetchJSON(`${baseUrl}/api`);
    return Object.entries(api); // [ ["/api/spells", { name: "Spells" }], ... ]
  }

  async function openDB(stores) {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(dbName, 1);
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        for (const store of stores) {
          if (!db.objectStoreNames.contains(store)) {
            db.createObjectStore(store, { keyPath: "url" });
          }
        }
      };
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }

  async function storeDetails(storeName, details) {
    const db = await openDB([storeName]);
    return new Promise((resolve, reject) => {
      const tx = db.transaction(storeName, "readwrite");
      const store = tx.objectStore(storeName);
      for (const item of details) store.put(item);
      tx.oncomplete = () => resolve();
      tx.onerror = () => reject(tx.error);
    });
  }

  async function loadFromDB(endpoints) {
    const db = await openDB(endpoints.map(e => e[0]));
    let result = {};
    for (const [endpoint] of endpoints) {
      const tx = db.transaction(endpoint, "readonly");
      const store = tx.objectStore(endpoint);
      const req = store.getAll();
      await new Promise(res => {
        req.onsuccess = () => {
          result[endpoint] = req.result.map(e => e.data);
          res();
        };
        req.onerror = () => res(); // Fehler werden ignoriert
      });
    }
    return result;
  }

  async function fetchAll() {
    const endpoints = await fetchEndpoints();
    progressEl.max = endpoints.length;
    progressEl.value = 0;
    let completed = 0;

    for (const [endpointPath, meta] of endpoints) {
      statusEl.textContent = `Lade Kategorie: ${endpointPath}`;

      try {
        const list = await fetchJSON(baseUrl + endpointPath);
        if (!Array.isArray(list.results)) continue;

        const detailData = await Promise.all(
          list.results.map(async item => {
            try {
              const detail = await fetchJSON(baseUrl + item.url);
              return { url: item.url, data: detail };
            } catch (err) {
              errorEl.textContent += `Fehler bei ${item.url}: ${err.message}\n`;
              return null;
            }
          })
        );

        const filtered = detailData.filter(e => e !== null);
        await storeDetails(endpointPath, filtered);
      } catch (err) {
        errorEl.textContent += `Fehler bei ${endpointPath}: ${err.message}\n`;
      }

      completed++;
      progressEl.value = completed;
    }

    statusEl.textContent = "Fertig mit Laden.";
    const data = await loadFromDB(endpoints);
    outputEl.textContent = JSON.stringify(data, null, 2);
  }

  async function refreshData() {
    const ok = confirm("Datenbank wirklich lÃ¶schen?");
    if (!ok) return;
    indexedDB.deleteDatabase(dbName);
    location.reload();
  }

  // Start
  fetchEndpoints().then(endpoints => {
    loadFromDB(endpoints).then(data => {
      if (Object.keys(data).some(k => data[k]?.length)) {
        statusEl.textContent = "Daten aus IndexedDB geladen.";
        outputEl.textContent = JSON.stringify(data, null, 2);
        progressEl.value = progressEl.max;
      } else {
        fetchAll();
      }
    });
  });
</script>
</body>
</html>