<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>D&D 5e explorer</title>
  <style>
    body {
      font-family: sans-serif;
      padding: 1em;
    }
    progress {
      width: 100%;
      height: 20px;
    }
    pre {
      max-height: 60vh;
      overflow-y: auto;
      background: #f5f5f5;
      padding: 1em;
      border: 1px solid #ccc;
    }
    button {
      margin-top: 1em;
    }
    .error {
      color: red;
      white-space: pre-wrap;
    }
  </style>
</head>
<body>
  <h1>D&D 5e explorer</h1>
  <p id="status">Initialisiere...</p>
  <progress id="progress" value="0" max="100"></progress>
  <pre id="output">Warte auf Start...</pre>
  <div id="error" class="error"></div>
  <button onclick="refreshData()">Daten neu laden</button>

  <script>
    const baseUrl = "https://www.dnd5eapi.co";
    const dbName = "dnd5e-db";
    const dbVersion = 1;
    const statusEl = document.getElementById("status");
    const progressEl = document.getElementById("progress");
    const outputEl = document.getElementById("output");
    const errorEl = document.getElementById("error");

    function openDatabase(stores) {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(dbName, dbVersion);
        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          for (const storeName of stores) {
            if (!db.objectStoreNames.contains(storeName)) {
              db.createObjectStore(storeName, { keyPath: "url" });
            }
          }
        };
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    }

    async function fetchEndpoints() {
      const response = await fetch(`${baseUrl}/api`);
      const json = await response.json();
      return Object.entries(json); // [ ["/api/spells", {name: "Spells"}], ... ]
    }

    function createWorkerScript() {
      return `
        self.onmessage = async function(e) {
          const { baseUrl, endpoint } = e.data;
          try {
            const res = await fetch(baseUrl + endpoint);
            const categoryData = await res.json();
            const details = [];
            if (Array.isArray(categoryData.results)) {
              for (const item of categoryData.results) {
                try {
                  const detailRes = await fetch(baseUrl + item.url);
                  const detail = await detailRes.json();
                  details.push({ url: item.url, data: detail });
                } catch (err) {
                  self.postMessage({ type: 'error', message: 'Fehler bei ' + item.url + ': ' + err.message });
                }
              }
            }
            self.postMessage({ type: 'done', endpoint, details });
          } catch (err) {
            self.postMessage({ type: 'error', message: 'Fehler bei ' + endpoint + ': ' + err.message });
          }
        };
      `;
    }

    async function storeInIndexedDB(storeName, data) {
      const db = await openDatabase([storeName]);
      return new Promise((resolve, reject) => {
        const tx = db.transaction(storeName, "readwrite");
        const store = tx.objectStore(storeName);
        for (const item of data) {
          store.put(item);
        }
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
      });
    }

    async function loadFromIndexedDB() {
      const endpoints = await fetchEndpoints();
      const db = await openDatabase(endpoints.map(([endpoint]) => endpoint));
      let fullData = {};
      return new Promise((resolve) => {
        let loaded = 0;
        for (const [endpoint] of endpoints) {
          const tx = db.transaction(endpoint, "readonly");
          const store = tx.objectStore(endpoint);
          const req = store.getAll();
          req.onsuccess = () => {
            fullData[endpoint] = req.result.map(item => item.data);
            loaded++;
            if (loaded === endpoints.length) {
              resolve(fullData);
            }
          };
          req.onerror = () => {
            console.warn(`Lesefehler in ${endpoint}:`, req.error);
            loaded++;
            if (loaded === endpoints.length) {
              resolve(fullData);
            }
          };
        }
      });
    }

    async function fetchAllData() {
      const endpoints = await fetchEndpoints();
      progressEl.max = endpoints.length;
      progressEl.value = 0;
      const blob = new Blob([createWorkerScript()], { type: "application/javascript" });
      const workerURL = URL.createObjectURL(blob);
      let finishedCount = 0;

      for (const [endpoint] of endpoints) {
        const worker = new Worker(workerURL);
        worker.postMessage({ baseUrl, endpoint });

        worker.onmessage = async (event) => {
          const { type, message, endpoint, details } = event.data;
          if (type === "done") {
            await storeInIndexedDB(endpoint, details);
            finishedCount++;
            progressEl.value = finishedCount;
            statusEl.textContent = `Fertig: ${endpoint}`;
            if (finishedCount === endpoints.length) {
              statusEl.textContent = "Alle Daten geladen!";
              const finalData = await loadFromIndexedDB();
              outputEl.textContent = JSON.stringify(finalData, null, 2);
            }
          } else if (type === "error") {
            errorEl.textContent += "[Fehler] " + message + "\n";
            console.error(message);
          }
        };

        worker.onerror = function(err) {
          const errMsg = `[Worker-Fehler] ${err.message}`;
          errorEl.textContent += errMsg + "\n";
          console.error(errMsg);
        };
      }
    }

    function refreshData() {
      const confirmed = confirm("Alle gespeicherten Daten wirklich löschen?");
      if (confirmed) {
        const deleteReq = indexedDB.deleteDatabase(dbName);
        deleteReq.onsuccess = () => location.reload();
        deleteReq.onerror = () => {
          errorEl.textContent = "Löschen der Datenbank fehlgeschlagen!";
        };
      }
    }

    // Start
    loadFromIndexedDB().then(data => {
      if (Object.keys(data).length > 0) {
        statusEl.textContent = "Daten aus IndexedDB geladen.";
        progressEl.value = progressEl.max;
        outputEl.textContent = JSON.stringify(data, null, 2);
      } else {
        fetchAllData();
      }
    });
  </script>
</body>
</html>