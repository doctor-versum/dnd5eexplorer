<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>D&D 5e explorer</title>
  <style>
    body {
      font-family: sans-serif;
      padding: 1em;
    }
    progress {
      width: 100%;
      height: 20px;
    }
    pre {
      max-height: 60vh;
      overflow-y: auto;
      background: #f5f5f5;
      padding: 1em;
      border: 1px solid #ccc;
    }
    button {
      margin-top: 1em;
    }
    .error {
      color: red;
      white-space: pre-wrap;
    }
  </style>
</head>
<body>
  <h1>D&D 5e explorer</h1>
  <p id="status">Initialisiere...</p>
  <progress id="progress" value="0" max="100"></progress>
  <pre id="output">Warte auf Start...</pre>
  <div id="error" class="error"></div>
  <pre id="error" style="color: red; white-space: pre-wrap; margin-top: 1em;"></pre>.
  <button onclick="refreshData()">Daten neu laden</button>

  <script>
  const baseUrl = "https://www.dnd5eapi.co";
  const dbName = "dnd5e-db";
  const statusEl = document.getElementById("status");
  const progressEl = document.getElementById("progress");
  const outputEl = document.getElementById("output");
  const errorEl = document.getElementById("error");

  function logError(msg, err) {
    const text = `${msg}${err?.message ? " – " + err.message : ""}`;
    console.error(text, err);
    errorEl.textContent += text + "\n";
  }

  async function fetchJSON(url) {
    try {
      const res = await fetch(url);
      if (!res.ok) throw new Error(`${url} returned ${res.status}`);
      return res.json();
    } catch (err) {
      logError(`Fehler beim Abrufen von ${url}`, err);
      throw err;
    }
  }

  async function fetchEndpoints() {
    try {
      const api = await fetchJSON(`${baseUrl}/api`);
      return Object.entries(api); // [ ["/api/spells", { name: "Spells" }], ... ]
    } catch (err) {
      logError("Fehler beim Abrufen der Endpunkte", err);
      return [];
    }
  }

  async function openDB(stores) {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(dbName, 1);
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        for (const store of stores) {
          if (!db.objectStoreNames.contains(store)) {
            db.createObjectStore(store, { keyPath: "url" });
          }
        }
      };
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => {
        logError("Fehler beim Öffnen der IndexedDB", request.error);
        reject(request.error);
      };
    });
  }

  async function storeDetails(storeName, details) {
    try {
      const db = await openDB([storeName]);
      return new Promise((resolve, reject) => {
        const tx = db.transaction(storeName, "readwrite");
        const store = tx.objectStore(storeName);
        for (const item of details) {
          store.put(item);
        }
        tx.oncomplete = () => resolve();
        tx.onerror = () => {
          logError(`Fehler beim Speichern in Store "${storeName}"`, tx.error);
          reject(tx.error);
        };
      });
    } catch (err) {
      logError(`Konnte Datenbank für "${storeName}" nicht öffnen`, err);
    }
  }

  async function loadFromDB(endpoints) {
    const db = await openDB(endpoints.map(e => e[0]));
    let result = {};
    for (const [endpoint] of endpoints) {
      const tx = db.transaction(endpoint, "readonly");
      const store = tx.objectStore(endpoint);
      const req = store.getAll();
      await new Promise(res => {
        req.onsuccess = () => {
          result[endpoint] = req.result.map(e => e.data);
          res();
        };
        req.onerror = () => {
          logError(`Fehler beim Lesen aus Store "${endpoint}"`, req.error);
          res();
        };
      });
    }
    return result;
  }

  async function fetchAll() {
    const endpoints = await fetchEndpoints();
    if (!endpoints.length) {
      logError("Keine Endpunkte gefunden – möglicherweise Netzwerkfehler?");
      return;
    }

    progressEl.max = endpoints.length;
    progressEl.value = 0;
    let completed = 0;

    for (const [endpointPath, meta] of endpoints) {
      statusEl.textContent = `Lade Kategorie: ${endpointPath}`;

      try {
        const list = await fetchJSON(baseUrl + endpointPath);
        if (!Array.isArray(list.results)) throw new Error("Ergebnis hat kein 'results'-Array");

        const detailData = await Promise.all(
          list.results.map(async item => {
            try {
              const detail = await fetchJSON(baseUrl + item.url);
              return { url: item.url, data: detail };
            } catch (err) {
              logError(`Fehler bei Detailabruf ${item.url}`, err);
              return null;
            }
          })
        );

        const filtered = detailData.filter(e => e !== null);
        await storeDetails(endpointPath, filtered);
      } catch (err) {
        logError(`Fehler bei Kategorie ${endpointPath}`, err);
      }

      completed++;
      progressEl.value = completed;
    }

    statusEl.textContent = "Fertig mit Laden.";
    const data = await loadFromDB(endpoints);
    outputEl.textContent = JSON.stringify(data, null, 2);
  }

  async function refreshData() {
    const ok = confirm("Datenbank wirklich löschen?");
    if (!ok) return;
    indexedDB.deleteDatabase(dbName);
    location.reload();
  }

  // Start
  fetchEndpoints().then(endpoints => {
    loadFromDB(endpoints).then(data => {
      const hasData = Object.keys(data).some(k => data[k]?.length);
      if (hasData) {
        statusEl.textContent = "Daten aus IndexedDB geladen.";
        outputEl.textContent = JSON.stringify(data, null, 2);
        progressEl.value = progressEl.max;
      } else {
        fetchAll();
      }
    });
  });
</script>
</body>
</html>