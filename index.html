<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>D&D 5e API (mit IndexedDB)</title>
  <style>
    body {
      font-family: sans-serif;
      padding: 1em;
    }
    progress {
      width: 100%;
      height: 20px;
    }
    pre {
      background: #f5f5f5;
      padding: 1em;
      border: 1px solid #ccc;
      overflow-x: auto;
    }
    button {
      margin: 0.2em 0;
      padding: 0.5em;
    }
    .hidden {
      display: none;
    }
    .back-button {
      margin-top: 1em;
    }
    .divider {
      margin: 1em 0;
      border-top: 1px solid #aaa;
    }
    .content-info {
      margin: 0.2em 1em;
      padding: 0.2em;
      border-left: 2px solid #ccc;
    }
    .content-level-1, .content-level-2, .content-level-3, .content-level-4 {
      margin-left: 1em;
      border-left: 2px dashed #ccc;
      padding-left: 0.5em;
      margin-bottom: 0.5em;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
<script>eruda.init();</script>
</head>
<body>
  <h1>D&D 5e API (mit Caching)</h1>
  <p id="status">Initialisiere...</p>
  <progress id="progress" value="0" max="100"></progress>

  <div id="mainMenu" class="hidden"></div>
  <div id="subMenu" class="hidden"></div>
  <button id="backButton" class="back-button hidden">Zurück</button>
  <div class="divider hidden" id="divider"></div>
  <div id="dataContainer"></div>

  <script>
    const baseUrl = "https://www.dnd5eapi.co";
    const dbName = "dnd5e-db";
    const storeName = "categories";
    const statusEl = document.getElementById("status");
    const progressEl = document.getElementById("progress");
    const mainMenu = document.getElementById("mainMenu");
    const subMenu = document.getElementById("subMenu");
    const dataContainer = document.getElementById("dataContainer");
    const backButton = document.getElementById("backButton");
    const divider = document.getElementById("divider");

    let db;
    let currentCategory = null;

    function openDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(dbName, 1);
        request.onupgradeneeded = e => {
          db = e.target.result;
          if (!db.objectStoreNames.contains(storeName)) {
            db.createObjectStore(storeName);
          }
        };
        request.onsuccess = e => {
          db = e.target.result;
          resolve(db);
        };
        request.onerror = e => reject(e);
      });
    }

    function saveToDB(key, value) {
      return new Promise((resolve, reject) => {
        const tx = db.transaction(storeName, "readwrite");
        const store = tx.objectStore(storeName);
        store.put(value, key);
        tx.oncomplete = () => resolve();
        tx.onerror = e => reject(e);
      });
    }

    function getFromDB(key) {
      return new Promise((resolve, reject) => {
        const tx = db.transaction(storeName, "readonly");
        const store = tx.objectStore(storeName);
        const request = store.get(key);
        request.onsuccess = () => resolve(request.result);
        request.onerror = e => reject(e);
      });
    }

    async function fetchJSON(url) {
      const res = await fetch(url);
      return res.json();
    }

    async function fetchAndStoreData() {
      const apiRoot = await fetchJSON(`${baseUrl}/api`);
      const entries = Object.entries(apiRoot);
      progressEl.max = entries.length;
      let count = 0;

      for (const [name, endpoint] of entries) {
        statusEl.textContent = `Lade Kategorie: ${name}`;
        const categoryData = await fetchJSON(`${baseUrl}${endpoint}`);
        const detailedData = {};

        if (Array.isArray(categoryData.results)) {
          for (const item of categoryData.results) {
            const detail = await fetchJSON(`${baseUrl}${item.url}`);
            detailedData[item.url] = detail;
          }
        }

        await saveToDB(name, {
          name,
          endpoint,
          data: detailedData,
          list: categoryData.results
        });

        count++;
        progressEl.value = count;
      }

      statusEl.textContent = "Fertig!";
      progressEl.classList.add("hidden");
      loadMainMenu();
    }

    function loadMainMenu() {
      statusEl.textContent = "Wähle eine Kategorie:";
      mainMenu.classList.remove("hidden");
      subMenu.classList.add("hidden");
      dataContainer.innerHTML = "";
      divider.classList.add("hidden");
      backButton.classList.add("hidden");

      const tx = db.transaction(storeName, "readonly");
      const store = tx.objectStore(storeName);
      const request = store.getAllKeys();

      request.onsuccess = async () => {
        const keys = request.result;
        mainMenu.innerHTML = "";
        for (const key of keys) {
          const btn = document.createElement("button");
          btn.textContent = key;
          btn.onclick = () => showSubMenu(key);
          mainMenu.appendChild(btn);
        }
      };
    }

    async function showSubMenu(category) {
      currentCategory = category;
      mainMenu.classList.add("hidden");
      subMenu.classList.remove("hidden");
      backButton.classList.remove("hidden");
      divider.classList.add("hidden");
      dataContainer.innerHTML = "";
      statusEl.textContent = `Wähle aus ${category}`;

      const entry = await getFromDB(category);
      subMenu.innerHTML = "";
      for (const item of entry.list) {
        const btn = document.createElement("button");
        btn.textContent = item.name || item.index;
        btn.onclick = () => showData(entry.data[item.url]);
        subMenu.appendChild(btn);
      }

      backButton.onclick = () => loadMainMenu();
    }

    function showData(data) {
      dataContainer.innerHTML = "";
      divider.classList.remove("hidden");
      renderJSON(data, dataContainer, 1);
    }

    function renderJSON(obj, parent, level) {
      if (Array.isArray(obj)) {
        obj.forEach(item => {
          const div = document.createElement("div");
          div.className = `content-level-${level}`;
          renderJSON(item, div, level + 1);
          parent.appendChild(div);
        });
      } else if (typeof obj === "object" && obj !== null) {
        const container = document.createElement("div");
        container.className = `content-level-${level}`;
        for (const [key, value] of Object.entries(obj)) {
          if (key === "url" && typeof value === "string") {
            const btn = document.createElement("button");
            btn.textContent = `Gehe zu: ${value}`;
            btn.onclick = async () => {
              const path = value.split("/api/")[1];
              if (path) {
                const parts = path.split("/");
                if (parts.length >= 2) {
                  const cat = parts[0];
                  const sub = parts[1];
                  const data = await getFromDB(cat);
                  if (data && data.data) {
                    showSubMenu(cat);
                    setTimeout(() => {
                      showData(data.data[`/api/${cat}/${sub}`]);
                    }, 100);
                  }
                }
              }
            };
            container.appendChild(btn);
          } else if (typeof value === "object") {
            const sub = document.createElement("div");
            sub.className = `content-level-${level}`;
            const label = document.createElement("div");
            label.textContent = key;
            sub.appendChild(label);
            renderJSON(value, sub, level + 1);
            container.appendChild(sub);
          } else {
            const info = document.createElement("div");
            info.className = "content-info";
            info.textContent = `${key}: ${value}`;
            container.appendChild(info);
          }
        }
        parent.appendChild(container);
      } else {
        const info = document.createElement("div");
        info.className = "content-info";
        info.textContent = obj;
        parent.appendChild(info);
      }
    }

    async function init() {
      await openDB();
      const keys = await new Promise((resolve, reject) => {
        const tx = db.transaction(storeName, "readonly");
        const store = tx.objectStore(storeName);
        const request = store.getAllKeys();
        request.onsuccess = () => resolve(request.result);
        request.onerror = e => reject(e);
      });

      if (keys.length > 0) {
        progressEl.classList.add("hidden");
        statusEl.textContent = "Daten aus Cache geladen.";
        loadMainMenu();
      } else {
        fetchAndStoreData();
      }
    }

    init();
  </script>
</body>
</html>